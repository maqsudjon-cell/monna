<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pangeya Essay Platform</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">

  <!--
    This file is based on the original Pangeya Essay Platform hosted on GitHub pages.
    The markup, styling and scripts have been preserved so the core functionality
    (writing, saving, editing and printing essays; teacher mode; theme switching)
    continue to work. This edition preserves the Light and Dark themes
    from the original. The former Neon theme and festive New Year mode
    (including weather effects and decorative stickers) have been removed
    entirely for a cleaner user experience.

    The Pangeya theme (green palette) from the original edition has been removed
    in this version as per user request. All references to the Pangeya theme,
    including styles, buttons and event handlers, have been stripped out to
    simplify the theme logic.

    Comment functionality has been removed in this version. All comment‚Äërelated
    styles, UI elements and scripts have been deleted. The platform focuses
    solely on writing and managing essays, feedback and AI interactions.
  -->
  <style>
    :root {
      /* base colours and sizing inherited from the original site */
      --bg-gradient: radial-gradient(circle at top left, #3b0764, #1e1b4b 40%, #020617 80%);
      --card-bg: rgba(15, 23, 42, 0.92);
      --accent: #a855f7;
      --accent2: #ec4899;
      --accent3: #22c55e;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --border-soft: rgba(148, 163, 184, 0.3);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh;
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-gradient);
      color: var(--text-main);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    /* Light and dark themes mirror the original implementation */
    .light-theme {
      --bg-gradient: linear-gradient(135deg, #e0e7ff, #f5f3ff);
      --card-bg: #ffffff;
      --text-main: #111827;
      --text-muted: #6b7280;
      --border-soft: rgba(148, 163, 184, 0.5);
    }
    .dark-theme {
      --bg-gradient: radial-gradient(circle at top, #020617, #020617 40%, #000000 100%);
      --card-bg: #020617;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    /*
      Glass theme ‚Äì inspired by iOS style glass surfaces.
      It uses translucent backgrounds and applies a backdrop blur on the
      container to give the impression of frosted glass.  Note: the glass
      theme remains defined here for completeness, but there is no built‚Äëin
      button to activate it. If needed, you can add your own trigger.
    */
    .glass-theme {
      --bg-gradient: linear-gradient(135deg, rgba(255,255,255,0.35), rgba(230,230,230,0.2));
      --card-bg: rgba(255, 255, 255, 0.2);
      --text-main: #0f172a;
      --text-muted: #334155;
      --border-soft: rgba(15, 23, 42, 0.25);
    }
    .glass-theme .inner {
      backdrop-filter: blur(16px);
    }

    /* Container styling preserved from original */
    .container {
      width: 100%;
      max-width: 900px;
      background: linear-gradient(145deg, rgba(88, 28, 135, 0.9), rgba(30, 64, 175, 0.9));
      padding: 2px;
      border-radius: 26px;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.55);
    }
    .inner {
      background: var(--card-bg);
      border-radius: 24px;
      padding: 20px 20px 18px;
    }
    @media (min-width: 768px) {
      .inner { padding: 24px 26px 22px; }
    }
    h1 {
      font-size: 22px;
      font-weight: 600;
      text-align: center;
      margin-bottom: 10px;
    }
    .subtitle {
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 14px;
    }
    .theme-switcher {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
    }
    .theme-btn {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
      font-size: 13px;
      font-weight: 500;
      transition: all .18s ease;
    }
    .theme-btn.active {
      background: linear-gradient(135deg, #a855f7, #ec4899);
      color: white;
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
    }
    label {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
      margin-top: 6px;
    }
    /* Input and textarea styling retained from original */
    input[type="text"], textarea {
      width: 100%;
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
      transition: border .15s ease, box-shadow .15s ease, background .15s ease;
    }
    textarea {
      min-height: 130px;
      resize: vertical;
    }

    /* Make the vocabulary definition box smaller.  Users often paste multiple
       vocab items into this box, so it should not take up as much vertical
       space as the essay textarea.  The global textarea rule above sets a
       fairly tall minimum height (130px).  We override it for the vocabulary
       definition input so that it appears as a compact field, while still
       allowing users to type or paste multiple lines if needed. */
    #definition {
      min-height: 80px;
    }
    input[type="text"]:focus, textarea:focus {
      border-color: #818cf8;
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.7);
      background: rgba(15, 23, 42, 1);
    }
    .btn {
      width: 100%;
      border: none;
      border-radius: 999px;
      padding: 11px 14px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 10px;
      transition: transform .1s ease, box-shadow .1s ease, opacity .15s ease;
      color: white;
      position: relative; /* to anchor stickers */
      overflow: hidden;
    }
    .btn-primary {
      background: linear-gradient(135deg, #a855f7, #ec4899);
      box-shadow: 0 10px 25px rgba(236, 72, 153, 0.4);
    }
    .btn-secondary {
      background: linear-gradient(135deg, #38bdf8, #6366f1);
      box-shadow: 0 8px 20px rgba(56, 189, 248, 0.35);
    }
    .btn-teacher {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      box-shadow: 0 8px 20px rgba(34, 197, 94, 0.35);
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(0); box-shadow: none; }

    /* Search controls for essay list ‚Äì provides a small name search and an AI
       button.  These controls appear next to the All Essays heading. */
    .essay-search-controls {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
      justify-content: flex-end;
    }
    .essay-search-controls input {
      flex: 1;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--border-soft);
      background: var(--card-bg);
      color: var(--text-main);
      font-size: 12px;
    }
    .essay-search-controls input::placeholder {
      color: var(--text-muted);
      font-style: italic;
    }
    .essay-search-controls button {
      padding: 5px 10px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      color: #ffffff;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: transform .1s ease;
    }
    .essay-search-controls button:hover { transform: translateY(-1px); }
    .essay-search-controls button:active { transform: translateY(0); }

    /* Vocabulary-related styles removed as the vocabulary feature is deprecated. */

    /* Chat section styling */
    .chat-messages {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 400px;
      min-height: 120px;
      width: 100%;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
      border-radius: 12px;
      margin-bottom: 12px;
      font-size: 14px;
      line-height: 1.4;
    }
    .chat-message {
      max-width: 90%;
      padding: 8px 12px;
      border-radius: 12px;
      word-wrap: break-word;
      white-space: pre-wrap;
    }
    .chat-message.user {
      align-self: flex-end;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #ffffff;
      border-radius: 12px 12px 0 12px;
    }
    .chat-message.assistant {
      align-self: flex-start;
      background: rgba(0, 0, 0, 0.2);
      color: #e5e7eb;
      border-radius: 12px 12px 12px 0;
    }
    .chat-input-area {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }
    .chat-input-area textarea {
      flex: 1;
      resize: none;
      padding: 8px 10px;
      border-radius: 12px;
      background: var(--input-bg, rgba(15, 23, 42, 0.8));
      color: #e5e7eb;
      border: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 14px;
      min-height: 48px;
    }
    /* Ensure the send button in the chat input area does not stretch to full width */
    .chat-input-area button {
      width: auto;
      flex-shrink: 0;
      white-space: nowrap;
    }

    /* Styling for the chat image upload button.  This button allows the
       user to select an image file from their device.  It uses the
       accent gradient similar to other primary buttons but is sized to
       its content. */
    .chat-image-btn {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #ffffff;
      border: none;
      border-radius: 999px;
      /* Reduce padding and font size to make the icon appear smaller */
      padding: 6px 8px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .1s ease, box-shadow .1s ease;
    }
    .chat-image-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
    }

    /* Styling for the clear chat button.  This button mirrors the style of
       the image upload button but is used to reset the conversation. */
    .chat-clear-btn {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #ffffff;
      border: none;
      border-radius: 999px;
      /* Match the reduced sizing of the image button */
      padding: 6px 8px;
      font-size: 14px;
      cursor: pointer;
      transition: transform .1s ease, box-shadow .1s ease;
    }
    .chat-clear-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
    }
    /* Ensure images within chat messages scale nicely and have rounded corners */
    .chat-message img {
      max-width: 100%;
      border-radius: 12px;
      display: block;
    }
    .chat-disclaimer {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 4px;
      text-align: center;
    }

    /* Modern chat UI styling */
    .chat-wrapper {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .chat-title {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-main);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .chat-credit-badge {
      font-size: 12px;
      background: var(--accent);
      color: #ffffff;
      padding: 2px 8px;
      border-radius: 999px;
    }
    .chat-body {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 8px;
    }
    .chat-input-area {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
    }
    .chat-input-area input {
      flex: 1;
      border: 1px solid var(--border-soft);
      border-radius: 999px;
      padding: 6px 12px;
      background: rgba(15, 23, 42, 0.8);
      color: var(--text-main);
      font-size: 14px;
      outline: none;
    }
    .send-btn {
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border: none;
      border-radius: 999px;
      color: #ffffff;
      padding: 6px 14px;
      font-size: 16px;
      cursor: pointer;
      transition: transform .1s ease, box-shadow .1s ease;
    }
    .send-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
    }
    .clear-btn {
      background: transparent;
      border: 1px solid var(--border-soft);
      border-radius: 999px;
      color: var(--text-main);
      padding: 6px 12px;
      font-size: 16px;
      cursor: pointer;
      transition: background .1s ease, transform .1s ease;
    }
    .clear-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-1px);
    }
    .typing {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 4px;
      margin-bottom: 8px;
    }
    .typing span {
      display: block;
      width: 6px;
      height: 6px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: blink 1.2s infinite ease-in-out;
    }
    .typing span:nth-child(2) { animation-delay: .2s; }
    .typing span:nth-child(3) { animation-delay: .4s; }
    .hidden { display: none !important; }
    @keyframes blink {
      0% { opacity: 0.2; }
      20% { opacity: 1; }
      100% { opacity: 0.2; }
    }

    /* Pixel hero container and canvas for the "Pangea" particle text animation.
       The container reserves vertical space below the page heading and ensures
       responsiveness.  The canvas fills the container, allowing the
       JavaScript animation to scale to the available width. */
    .pixel-hero {
      position: relative;
      width: 100%;
      /* Height is tuned to provide enough room for the text particles.
         Adjust this value if the animation appears too cramped or too
         spread out on small screens. */
      height: 160px;
      margin: 14px 0 20px;
    }
    .pixel-hero canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Fallback text container used when the pixel animation is hidden on very
       small screens.  It fills the same space as the canvas and centers
       the fallback word both vertically and horizontally. */
    .pixel-fallback {
      display: none;
      width: 100%;
      height: 100%;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      color: var(--accent);
      overflow: hidden;
      padding: 0 4px;
    }

    /* Reduce the height of the pixel animation on smaller screens to
       maintain a balanced layout.  Without this rule the canvas may
       dominate the hero area on very narrow viewports. */
    @media (max-width: 640px) {
      .pixel-hero {
        height: 120px;
      }
    }

    /* On very small screens (mobile phones), further reduce the height of the
       pixel hero container to prevent vertical scrolling and ensure the
       heading remains visible without cutting off content. */
    @media (max-width: 480px) {
      .pixel-hero {
        height: 100px;
      }
    }

    /* AI feedback block styling inside essays */
    .ai-feedback {
      margin-top: 4px;
      padding: 7px 8px;
      background: rgba(56, 189, 248, 0.16);
      border-left: 3px solid #38bdf8;
      border-radius: 10px;
      font-size: 13px;
      color: var(--text-main);
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Pangeya theme overrides removed.
       Previously there were green palette overrides for buttons and chips
       associated with the Pangeya theme. Since the Pangeya theme has been
       deprecated, these rules have been removed entirely. */

    .teacher-panel {
      display: none;
      margin-top: 8px;
    }
    .teacher-panel input { margin-top: 6px; }
    .teacher-panel .btn-enter { margin-top: 8px; }
    .section-title {
      margin-top: 18px;
      margin-bottom: 8px;
      font-size: 15px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .section-title span.icon { font-size: 17px; }
    .essays-list {
      margin-top: 4px;
      max-height: 380px;
      overflow-y: auto;
      padding-right: 2px;
    }
    .essay-card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: 18px;
      padding: 10px 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      margin-bottom: 8px;
      font-size: 13px;
      position: relative; /* for sticker positioning */
    }
    .essay-header {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 4px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .essay-name { font-weight: 500; }
    .essay-text {
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: anywhere;
      margin-bottom: 6px;
      margin-top: 2px;
      color: var(--text-main);
    }
    .word-count { /* inserted from script */ }
    .feedback {
      margin-top: 4px;
      padding: 7px 8px;
      background: rgba(22, 163, 74, 0.16);
      border-left: 3px solid #22c55e;
      border-radius: 10px;
      font-size: 13px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .feedback .fb-check, .feedback .fb-cross {
      display: block;
      padding-left: 22px;
      position: relative;
      margin: 4px 0;
    }
    .feedback .fb-check::before {
      content: '‚úî';
      position: absolute;
      left: 0;
      color: #22c55e;
    }
    .feedback .fb-cross::before {
      content: '‚úò';
      position: absolute;
      left: 0;
      color: #ef4444;
    }
    .essay-actions {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .chip-btn {
      border: none;
      border-radius: 999px;
      padding: 5px 11px;
      font-size: 11px;
      cursor: pointer;
      color: white;
    }
    .chip-edit { background: #22c55e; }
    .chip-delete { background: #ef4444; }
    .chip-feedback { background: #0ea5e9; }
    /* Added style for per-essay PDF download button */
    .chip-download { background: #f59e0b; }
    .chip-btn:active { transform: translateY(1px); }
    /* Toolbar styling for rich text editing */
    .toolbar {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
    }
    .icon-btn {
      background: transparent;
      border: 1px solid var(--border-soft);
      border-radius: 4px;
      padding: 4px 6px;
      font-size: 13px;
      color: var(--text-main);
      cursor: pointer;
    }
    .icon-btn:hover {
      background: var(--accent);
      color: #fff;
    }
    .edit-area {
      min-height: 120px;
      max-height: 300px;
      overflow-y: auto;
      padding: 8px;
      border: 1px solid var(--border-soft);
      border-radius: 6px;
      font-size: 13px;
      background: var(--card-bg);
      color: var(--text-main);
      white-space: pre-wrap;
      word-wrap: break-word;
      outline: none;
    }
    .feedback-essay {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 8px;
      padding: 8px;
      border: 1px solid var(--border-soft);
      border-radius: 6px;
      font-size: 12px;
      background: var(--card-bg);
      color: var(--text-main);
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    /* Light theme adjustments for cards and feedback */
    .light-theme .essay-card {
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(0, 0, 0, 0.12);
    }
    .light-theme .essay-card .essay-text,
    .light-theme .essay-card .feedback {
      color: #111827;
    }
    .light-theme .feedback {
      background: rgba(34, 197, 94, 0.16);
      border-left: 3px solid #16a34a;
    }
    .light-theme .edit-area,
    .light-theme .feedback-essay {
      background: #f9fafb;
      color: #111827;
      border: 1px solid rgba(0, 0, 0, 0.12);
    }
    .light-theme .icon-btn {
      border: 1px solid rgba(0, 0, 0, 0.12);
      color: #111827;
    }
    .light-theme input[type="text"],
    .light-theme textarea {
      background: #f9fafb;
      color: #111827;
      border: 1px solid rgba(0, 0, 0, 0.15);
    }
    .light-theme input[type="text"]::placeholder,
    .light-theme textarea::placeholder {
      color: #6b7280;
    }
    .light-theme input[type="text"]:focus,
    .light-theme textarea:focus {
      background: #ffffff;
      border-color: #818cf8;
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.7);
    }
    .light-theme .modal-content {
      background: #ffffff;
      color: #111827;
    }
    .light-theme #editArea,
    .light-theme #feedbackArea {
      background: #f9fafb;
      color: #111827;
      border: 1px solid rgba(0, 0, 0, 0.15);
    }
    .light-theme #editArea:focus,
    .light-theme #feedbackArea:focus {
      background: #ffffff;
      border-color: #818cf8;
    }
    /* Highlight, underline and strike styling */
    mark, .user-highlight { background-color: #fef08a; color: #111827; }
    u, .underline-text { text-decoration: underline; }
    s, .strike-text { text-decoration: line-through; }
    /* Modal styling retained */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      padding: 16px;
      z-index: 999;
    }
    .modal-content {
      width: 100%;
      max-width: 720px;
      background: #020617;
      color: #e5e7eb;
      border-radius: 18px;
      padding: 16px 16px 14px;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.8);
    }
    .modal-content h3 {
      margin-bottom: 8px;
      font-size: 16px;
      font-weight: 500;
    }
    #editArea, #feedbackArea {
      width: 100%;
      min-height: 200px;
      max-height: 60vh;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: #020617;
      color: #e5e7eb;
      font-size: 14px;
      resize: vertical;
      outline: none;
    }
    #editArea:focus, #feedbackArea:focus {
      border-color: #818cf8;
      box-shadow: 0 0 0 1px rgba(129, 140, 248, 0.7);
    }
    .modal-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 8px;
    }
    .small-btn {
      padding: 7px 14px;
      border-radius: 999px;
      border: none;
      font-size: 12px;
      cursor: pointer;
      color: white;
    }
    .small-save { background: #22c55e; }
    .small-cancel { background: #ef4444; }
    @media (max-width: 480px) {
      h1 { font-size: 18px; }
      .subtitle { font-size: 11px; }
      .essay-card { font-size: 12px; }
      .modal-content { padding: 14px; }
      #editArea, #feedbackArea { min-height: 170px; }
    }
    /* Remove New Year decorations, snow, rain and weather effects. */
    /* The name-wrapper remains defined for structural purposes */
    .name-wrapper {
      position: relative;
    }

    /* Valentine stickers.  Add a heart icon after each button to give a festive
       Valentine feel.  The icon is absolutely positioned inside the button.
       Pointer events are disabled to avoid interfering with button clicks. */
    .btn::after {
      content: 'üíñ';
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
      pointer-events: none;
    }

    /* Style the gift message section on each essay card.  It displays the
       Valentine's message along with a heart icon. */
    .gift-message {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      margin-top: 4px;
      color: var(--text-main);
    }
    .gift-message .valentine-sticker {
      font-size: 14px;
    }

    /* Remove all comment section styles (comment buttons, section, list etc.) */
    /* The following styles were removed since comment features have been
       deprecated. They are intentionally left empty to indicate removal. */

  </style>
</head>
<body class="dark-theme">
  <!-- Vocabulary and Chat features have been removed -->
  <div class="container">
    <div id="essaySection" class="inner">
      <!-- The hero heading is split into separate spans to allow editing of
           the text while preserving the decorative star.  The star is
           contained in #heroStar and the editable text in #heroTitle. -->
      <h1><span id="heroStar">üíñ</span> <span id="heroTitle">Pangeya Essay Platform</span></h1>
      <!-- Subtitle also receives an id for editing. -->
      <div class="subtitle" id="heroSubtitle">Write, save and print essays. Teachers can leave feedback with a secret key.</div>
      <!-- Pixel animation hero container for the word "Pangea".  This canvas
           will be sized via CSS and the accompanying script will draw
           individual particles that assemble into the letters.  Placing
           this element here ensures the animation sits neatly below the
           heading without disturbing the rest of the layout. -->
      <div class="pixel-hero" aria-hidden="true">
        <canvas id="pixelCanvas"></canvas>
        <!-- Fallback text for very small screens where the canvas-based
             animation may not be suitable.  This element is populated and
             displayed dynamically via JavaScript when the viewport is too
             narrow for the particle effect. -->
        <div id="pixelFallback" class="pixel-fallback"></div>
      </div>
      <!-- Theme switcher: Light and Dark -->
      <div class="theme-switcher">
        <button class="theme-btn" id="lightTheme">Light</button>
        <button class="theme-btn active" id="darkTheme">Dark</button>
      </div>
      <!-- Name input -->
      <label for="name">Your name</label>
      <div class="name-wrapper">
        <input id="name" type="text" placeholder="Enter your name" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
      </div>
      <!-- Essay textarea -->
      <label for="essay">Write your essay</label>
      <textarea id="essay" placeholder="Write your essay..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
      <!-- Gift message input (Valentine's message) -->
      <label for="giftMessage">Gift message</label>
      <input id="giftMessage" type="text" placeholder="Optional Valentine's message (e.g. Happy Valentine's Day!)" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
      <!-- Primary actions -->
      <button class="btn btn-primary" id="submitBtn">Submit</button>
      <button class="btn btn-secondary" id="pdfBtn">Download PDF</button>
      <button class="btn btn-teacher" id="teacherToggle">Teacher Login</button>
      <!-- Hidden teacher panel revealed when logging in -->
      <div class="teacher-panel" id="teacherPanel">
        <input id="teacherKey" type="text" placeholder="Enter teacher key" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        <button class="btn btn-teacher btn-enter" id="teacherEnter">Enter</button>
      </div>
      <!-- Essays list heading -->
      <div class="section-title">
        <span>All Essays</span>
      </div>
    <!-- Search bar for finding essays by author name -->
    <div class="essay-search-controls">
        <input id="essaySearch" type="text" placeholder="Search essays...">
    </div>
      <div class="essays-list" id="essaysList"></div>
    </div> <!-- end of essaySection -->

    <!-- Chat section -->
    <div id="chatSection" class="chat-wrapper">
      <div class="chat-header">
        <div class="chat-title">ü§ñ PangeyaAI</div>
        <div id="chatCredit" class="chat-credit-badge"></div>
      </div>
      <div id="chatMessages" class="chat-body"></div>
      <!-- Typing animation shown while waiting for a reply -->
      <div id="typingIndicator" class="typing hidden"><span></span><span></span><span></span></div>
      <div class="chat-input-area">
        <input id="chatInput" type="text" placeholder="Ask PangeyaAI..." autocomplete="off">
        <button id="chatSendBtn" class="send-btn" type="button">‚û§</button>
        <button id="chatClearBtn" class="clear-btn" type="button">üóë</button>
      </div>
      <div class="chat-disclaimer">Type "please" three times consecutively to receive 13 extra messages.</div>
    </div>

    <!-- Vocabulary and Chat sections removed -->
  </div>
  <!-- Weather effects removed; no snow or rain -->
  <!-- Edit Essay Modal -->
  <div class="modal" id="editModal">
    <div class="modal-content">
      <h3>Edit essay</h3>
      <!-- toolbar for text formatting -->
      <div class="toolbar">
        <button class="icon-btn" title="Highlight Text" onclick="highlightSelection()">üñç</button>
        <button class="icon-btn" title="Underline Text" onclick="underlineSelection()"><u>U</u></button>
        <button class="icon-btn" title="Strikethrough Text" onclick="strikeSelection()"><s>S</s></button>
      </div>
      <div id="editArea" class="edit-area" contenteditable="true" spellcheck="false" autocorrect="off" autocapitalize="off"></div>

      <!-- Gift message input (Valentine's message) -->
      <label for="giftMessageEdit">Gift message</label>
      <input id="giftMessageEdit" type="text" placeholder="Optional Valentine's message" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
      <div class="modal-actions">
        <button class="small-btn small-save" onclick="saveEdit()">Save</button>
        <button class="small-btn small-cancel" onclick="closeEditModal()">Cancel</button>
      </div>
    </div>
  </div>
  <!-- Feedback Modal -->
  <div class="modal" id="feedbackModal">
    <div class="modal-content">
      <h3>Add / edit teacher feedback</h3>
      <div id="feedbackEssay" class="feedback-essay" contenteditable="true" spellcheck="false" autocorrect="off" autocapitalize="off"></div>
      <div class="toolbar">
        <button class="icon-btn" title="Highlight Text" onclick="highlightSelection()">üñç</button>
        <button class="icon-btn" title="Underline Text" onclick="underlineSelection()"><u>U</u></button>
        <button class="icon-btn" title="Strikethrough Text" onclick="strikeSelection()"><s>S</s></button>
      </div>
      <textarea id="feedbackArea" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
      <div class="modal-actions">
        <button class="small-btn small-save" onclick="saveFeedback()">Save</button>
        <button class="small-btn small-cancel" onclick="closeFeedbackModal()">Cancel</button>
      </div>
    </div>
  </div>
  <!-- About / Info Modal -->
  <div class="modal" id="infoModal">
    <div class="modal-content">
      <h3>Author Information</h3>
      <div style="font-size:14px; line-height:1.6; white-space:pre-wrap;">üë§ Developed by: Maqsudjon Polatov
Creator of:
‚Ä¢ Pangeya Essay Platform
‚Ä¢ Uzglidex Marketplace
‚Ä¢ 37P.AI automated tools
‚Ä¢ NubAI medical assistant
‚Ä¢ Matsumi music project

üìå Support development
If you would like to support future updates and improvements,
you can send a donation to the following card:

üí≥ 9860 6004 0548 1208

Or pay via QR:</div>
      <img src="donation_qr.png" alt="Donation QR Code" class="donation-qr" onerror="this.style.display='none'">
      <p style="font-size:13px; margin-top:12px; color:var(--text-muted);">Press <strong>Ctrl + `</strong> again to close this window.</p>
      <div class="modal-actions">
        <button class="small-btn small-cancel" onclick="toggleInfoModal()">Close</button>
      </div>
    </div>
  </div>
  <!-- User Guide Modal -->
  <div class="modal" id="guideModal">
    <div class="modal-content">
      <h3>User Guide</h3>
      <h4 style="margin-top:10px; font-size:15px;">For Students</h4>
      <p style="font-size:13px; margin-bottom:8px;">1. Enter your name in the <em>Your name</em> field.</p>
      <p style="font-size:13px; margin-bottom:8px;">2. Write your essay in the <em>Write your essay</em> box.</p>
      <p style="font-size:13px; margin-bottom:8px;">3. Click <strong>Submit</strong> to save your essay to the cloud.</p>
      <p style="font-size:13px; margin-bottom:8px;">4. You can edit your essay by clicking the <strong>Edit</strong> button next to it.</p>
      <p style="font-size:13px; margin-bottom:8px;">5. To download your essay as a PDF, click <strong>Download PDF</strong>.</p>
      <h4 style="margin-top:14px; font-size:15px;">For Teachers</h4>
      <p style="font-size:13px; margin-bottom:8px;">1. Enter the secret teacher key in the <em>Teacher Key</em> field and click <strong>Enter</strong> to access teacher mode.</p>
      <p style="font-size:13px; margin-bottom:8px;">2. Once in teacher mode, you can edit any essay, highlight important sections, underline useful phrases, or strike through errors.</p>
      <p style="font-size:13px; margin-bottom:8px;">3. You can also add or edit feedback by clicking <strong>Add/Edit Feedback</strong> next to an essay.</p>
      <p style="font-size:13px; margin-bottom:8px;">4. The teacher key is confidential. If you need the key, please contact <strong>Maqsudjon Polatov</strong> personally to request it.</p>
      <p style="font-size:13px; margin-bottom:8px;">Press <strong>Ctrl + ;</strong> again to close this window and return to the platform.</p>
      <div class="modal-actions">
        <button class="small-btn small-cancel" onclick="toggleGuideModal()">Close</button>
      </div>
    </div>
  </div>
  <!-- Include jsPDF from CDN for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- Main application script; imported modules from Firebase remain unchanged.  Additional
       functions implement the new Glass theme, New Year decorations and toggle logic.
       The Pangeya theme code and related event handlers have been removed.
       Comment-related functions and UI have been removed from the script as well. -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";
    import {
      getFirestore,
      collection,
      addDoc,
      getDocs,
      doc,
      updateDoc,
      deleteDoc,
      getDoc,
  setDoc,
  query,
  orderBy,
  serverTimestamp
    } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // Constants
    const TEACHER_KEY = 'CTNLC';
    let teacherMode = false;
    let currentEditId = null;
    let currentFeedbackId = null;

    // =====================================================================
    // Global state and helpers for essay rendering
    // ---------------------------------------------------------------------
    // A counter to track the most recent essay fetch. Each call to
    // renderEssays() increments this value. When an async fetch resolves,
    // the render only proceeds if the captured requestId matches the global
    // essayRequestCounter. This prevents stale data from overwriting
    // newly fetched results when multiple renders are triggered in quick
    // succession (for example, switching themes or performing searches).
    let essayRequestCounter = 0;
    // Holds the latest full list of essays retrieved from Firestore.  All
    // filtering operations operate on this array to avoid mixing results
    // from different fetches.
    let allEssays = [];

    // Counter and global state for vocabulary requests. Similar to essays,
    // these help avoid stale renders when multiple search/filter operations
    // occur rapidly. Each call to renderVocab increments vocabRequestCounter
    // and stores fetched items in allVocab.
    // Vocabulary state has been removed; no counter or storage is required.

    // Global state for chat messages.  chatHistory holds an array of
    // messages exchanged with the AI.  Each message is an object with
    // a 'role' (either 'user' or 'assistant') and a 'content' string.
    let chatHistory = [];
    // Counter to guard against stale AI responses.  Each call to
    // sendChatMessage() increments this value.  When an API response
    // arrives, it only updates the UI if the captured request ID matches
    // the latest chatRequestCounter.
    let chatRequestCounter = 0;
    // The API key is not stored on the client.  All AI requests are proxied via
    // backend endpoints where the key is securely managed.

    // Endpoints for serverless functions hosted on Vercel.  The chat endpoint proxies
    // user messages to OpenAI and returns a reply.  The essay feedback
    // endpoint evaluates a single essay and returns band score and comments.
    const CHAT_ENDPOINT = 'https://pangeya-ai.vercel.app/api/chat';
    const FEEDBACK_ENDPOINT = 'https://pangeya-ai.vercel.app/api/essay-feedback';

    // -----------------------------------------------------------------
    // Local storage helpers for chat credits and feedback usage
    // -----------------------------------------------------------------
    function getChatLimit() {
      const val = localStorage.getItem('pangeya_chat_limit');
      return val ? parseInt(val, 10) : 13;
    }
    function setChatLimit(val) {
      localStorage.setItem('pangeya_chat_limit', String(val));
    }
    function getPleaseCount() {
      const val = localStorage.getItem('pangeya_please_count');
      return val ? parseInt(val, 10) : 0;
    }
    function setPleaseCount(val) {
      localStorage.setItem('pangeya_please_count', String(val));
    }
    function getFeedbackUsed() {
      return localStorage.getItem('pangeya_feedback_used') === 'true';
    }
    function setFeedbackUsed(val) {
      localStorage.setItem('pangeya_feedback_used', val ? 'true' : 'false');
    }
    // Generate or retrieve a unique identifier for this user.  This value is
    // stored in localStorage and used by the backend to scope chat and
    // essay feedback requests.  If not present, a new ID is generated.
    function getUserId() {
      let id = localStorage.getItem('pangeya_user_id');
      if (!id) {
        id = 'user-' + Math.random().toString(36).substring(2, 10);
        localStorage.setItem('pangeya_user_id', id);
      }
      return id;
    }
    // Display remaining chat credits to the user.
    function updateChatCredit() {
      const creditEl = document.getElementById('chatCredit');
      if (creditEl) {
        creditEl.textContent = 'Chat credits: ' + getChatLimit();
      }
    }

    // System prompt defining PangeyaAI's persona and guidelines.  This
    // prompt instructs the assistant to behave like an IELTS examiner and
    // produce high‚Äëquality essays according to official band descriptors
    // while avoiding informal language or generic responses.  It also
    // contains restrictions and capabilities specific to the PangeyaAI
    // brand.  The prompt should remain unchanged to ensure consistent
    // behavior across conversations.
    const SYSTEM_PROMPT = `You are PangeyaAI, a professional AI assistant designed specifically to help users prepare for the IELTS Academic and General Training Writing exams.

Your primary responsibility is to assist users with IELTS Writing Task 1 and Task 2 by producing high-quality, band 7.0‚Äì9.0 level essays that strictly follow the official IELTS Band Descriptors:
‚Ä¢ Task Response / Task Achievement
‚Ä¢ Coherence and Cohesion
‚Ä¢ Lexical Resource
‚Ä¢ Grammatical Range and Accuracy

You must always think and respond from the perspective of an IELTS examiner.

‚∏ª

Writing Standards (Mandatory)
‚Ä¢ Use formal, academic English only
‚Ä¢ Follow a clear and logical paragraph structure:
  ‚Ä¢ Introduction
  ‚Ä¢ Body Paragraph 1
  ‚Ä¢ Body Paragraph 2
  ‚Ä¢ (Conclusion where appropriate)
‚Ä¢ Apply strong topic sentences, clear explanations, and relevant examples
‚Ä¢ Maintain logical flow using appropriate cohesive devices (e.g. however, moreover, in contrast, as a result)
‚Ä¢ Use a wide range of complex and compound sentence structures, including:
  ‚Ä¢ Relative clauses
  ‚Ä¢ Conditionals
  ‚Ä¢ Passive voice
  ‚Ä¢ Concession structures (although, despite, in spite of)

‚∏ª

Lexical Requirements
‚Ä¢ Use IELTS-appropriate topic vocabulary
‚Ä¢ Apply natural collocations and precise word choices
‚Ä¢ Avoid repetition and unnatural or overly memorized expressions
‚Ä¢ Maintain clarity and academic tone at all times

‚∏ª

Strict Restrictions
‚Ä¢ Do NOT provide short, generic, or underdeveloped answers
‚Ä¢ Do NOT go off topic or include irrelevant ideas
‚Ä¢ Do NOT mention being an AI or language model
‚Ä¢ Do NOT produce low-band (Band 5‚Äì6) structures or language
‚Ä¢ Do NOT use informal language or contractions

‚∏ª

Additional Capabilities

When required, you may:
‚Ä¢ Evaluate essays and estimate an IELTS band score
‚Ä¢ Explain strengths and weaknesses clearly
‚Ä¢ Rewrite or improve essays to a higher band level
‚Ä¢ Adapt writing to different task types:
  ‚Ä¢ Opinion (Agree/Disagree)
  ‚Ä¢ Discussion
  ‚Ä¢ Problem‚ÄìSolution
  ‚Ä¢ Advantages‚ÄìDisadvantages

‚∏ª

Brand Identity

You represent PangeyaAI, the intelligent core of a modern and reliable IELTS preparation platform. Every response must be accurate, structured, exam-oriented, and designed to help users achieve the highest possible IELTS score.`;

    /**
     * Render the chat messages into the chatMessages container.  Clears
     * any existing content and builds message bubbles for each entry
     * stored in chatHistory.  User messages are right‚Äëaligned with an
     * accent gradient, while assistant messages are left‚Äëaligned with a
     * muted background.  After rendering, the container scrolls to the
     * bottom to show the latest message.
     */
    function renderChat() {
      const container = document.getElementById('chatMessages');
      if (!container) return;
      container.innerHTML = '';
      chatHistory.forEach(msg => {
        const div = document.createElement('div');
        div.classList.add('chat-message');
        div.classList.add(msg.role === 'user' ? 'user' : 'assistant');
        // If this message contains an image, display the image instead of text.
        if (msg.imageData) {
          const img = document.createElement('img');
          img.src = msg.imageData;
          img.alt = 'User image';
          div.appendChild(img);
          // Optionally include any accompanying text below the image
          if (msg.content) {
            const p = document.createElement('p');
            p.textContent = msg.content;
            div.appendChild(p);
          }
        } else {
          // Text message
          div.textContent = msg.content;
        }
        container.appendChild(div);
      });
      // Scroll to bottom to show the latest messages
      container.scrollTop = container.scrollHeight;
    }

    /**
     * Show the chat section and hide the essay/vocab sections.  When switching
     * to the chat, ensure the chat history is rendered and the scroll is
     * positioned at the bottom.
     */
    function switchToChat() {
      const essaySection = document.getElementById('essaySection');
      const chatSection = document.getElementById('chatSection');
      // Hide the essay area when switching to the chat
      if (essaySection) essaySection.style.display = 'none';
      // Show the chat and render the existing history
      if (chatSection) {
        chatSection.style.display = 'block';
        renderChat();
      }
    }

    /* Weather effects and toggle have been removed. */

    /**
     * Send the current input from the chat box to the OpenAI API.
     * Adds the user's message to chatHistory and renders it immediately.
     * Then performs a POST request to the chat API.  When a response
     * arrives, verifies that it is not stale (matches the current
     * chatRequestCounter) before updating chatHistory and re‚Äërendering.
     */
    async function sendChatMessage() {
      const input = document.getElementById('chatInput');
      if (!input) return;
      const text = (input.value || '').trim();
      if (!text) return;
      const lower = text.toLowerCase();
      // Retrieve current credits and please count
      let credits = getChatLimit();
      let pleaseCount = getPleaseCount();
      // If user has no credits and message isn't "please", inform them and exit
      if (credits <= 0 && lower !== 'please') {
        chatHistory.push({ role: 'assistant', content: 'No chat credits left. Type "please" three times consecutively to receive 13 extra messages.' });
        input.value = '';
        renderChat();
        updateChatCredit();
        return;
      }
      // Add user message to history
      chatHistory.push({ role: 'user', content: text });
      input.value = '';
      renderChat();
      // Decrement a credit for every message (including "please")
      credits -= 1;
      // Handle "please" logic
      if (lower === 'please') {
        pleaseCount += 1;
        if (pleaseCount >= 3) {
          credits += 13;
          pleaseCount = 0;
          chatHistory.push({ role: 'assistant', content: 'You have been granted 13 extra chat credits. Remaining credits: ' + credits });
          renderChat();
        }
        setChatLimit(credits);
        setPleaseCount(pleaseCount);
        updateChatCredit();
        // Do not send "please" to the AI
        return;
      } else {
        // Reset please count for any other message
        pleaseCount = 0;
        setPleaseCount(0);
      }
      // Update credits in storage
      setChatLimit(credits);
      updateChatCredit();
      // Show typing indicator
      const typingEl = document.getElementById('typingIndicator');
      if (typingEl) typingEl.classList.remove('hidden');
      // Increment request counter and capture id for this call
      const myChatRequestId = ++chatRequestCounter;
      try {
        // Prepare the payload for the backend.  Send the system prompt and the
        // current chat history (without images) so that the AI maintains context.
        const userMessages = chatHistory
          .filter(msg => !msg.imageData)
          .map(msg => ({ role: msg.role, content: msg.content }));
        const payload = {
          message: text,
          chatHistory: userMessages,
          systemPrompt: SYSTEM_PROMPT,
          model: chatHistory.some(m => m.imageData) ? 'gpt-4o' : 'gpt-3.5-turbo',
          userId: getUserId()
        };
        const response = await fetch(CHAT_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (myChatRequestId !== chatRequestCounter) return;
        const data = await response.json();
        const assistantMsg = data && data.reply
          ? data.reply.trim()
          : (data && data.error ? data.error : 'Sorry, I could not get a response.');
        chatHistory.push({ role: 'assistant', content: assistantMsg });
        renderChat();
      } catch (err) {
        console.error('Chat error:', err);
        if (myChatRequestId === chatRequestCounter) {
          chatHistory.push({ role: 'assistant', content: 'Sorry, there was an error communicating with the AI.' });
          renderChat();
        }
      } finally {
        if (typingEl) typingEl.classList.add('hidden');
      }
    }

    // The platform previously supported image uploads in chat. This functionality
    // has been removed to simplify the interface and improve performance.

    /**
     * Clear the current chat history.  Resets chatHistory and chatRequestCounter
     * and re-renders the chat container to remove all messages.
     */
    function clearChat() {
      chatHistory = [];
      chatRequestCounter = 0;
      renderChat();
      updateChatCredit();
    }

    // The old getAIFeedback function has been removed.  Per‚Äëessay AI feedback is handled by getEssayAIFeedback().

    /**
     * Fetch AI-generated feedback for a specific essay.  This function is
     * called when the user clicks the "Get AI Feedback" chip on an essay
     * card. Each feedback request consumes one chat credit but there is
     * no per‚Äësession limit on the number of feedback requests.  If the
     * user has no chat credits remaining, an alert is shown and the
     * request is not sent.  When the request is in flight, the
     * feedback button is disabled and a loading message is displayed in
     * the essay card.  Once a response is received from the server, the
     * AI feedback section is populated and the button remains disabled.
     *
     * @param {string} docId Firestore document ID of the essay
     * @param {Object} data The essay data containing at least `essay` and `name`
     */
    async function getEssayAIFeedback(docId, data) {
      // Check available chat credits. If none remain, inform the user and exit.
      let credits = getChatLimit();
      if (credits <= 0) {
        alert('You do not have any chat credits remaining to request AI feedback.');
        return;
      }
      // Decrement the credit for this feedback request and update the display.
      credits -= 1;
      setChatLimit(credits);
      updateChatCredit();
      // Locate the button and feedback container for this essay
      const aiBtn = document.getElementById('aiFeedbackBtn-' + docId);
      const aiContainer = document.getElementById('aiFeedback-' + docId);
      if (aiBtn) {
        aiBtn.disabled = true;
        aiBtn.textContent = 'Loading...';
      }
      if (aiContainer) {
        aiContainer.classList.remove('hidden');
        aiContainer.textContent = 'Fetching AI feedback...';
      }
      // Compose the request payload for the feedback endpoint
      try {
        const payload = {
          essay: data.essay || '',
          name: data.name || 'Unknown',
          userId: getUserId(),
          systemPrompt: SYSTEM_PROMPT
        };
        const response = await fetch(FEEDBACK_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const result = await response.json();
        // Extract feedback text from the response; support multiple property names
        let feedbackText = '';
        if (result) {
          if (typeof result === 'string') {
            feedbackText = result;
          } else if (result.feedback) {
            feedbackText = result.feedback;
          } else if (result.reply) {
            feedbackText = result.reply;
          } else if (result.comment) {
            feedbackText = result.comment;
          } else {
            // Fallback: stringify entire response
            feedbackText = JSON.stringify(result);
          }
        } else {
          feedbackText = 'No feedback returned.';
        }
        // Format and display the feedback
        if (aiContainer) {
          // Escape HTML to avoid injection, then convert newlines to <br>
          const safe = escapeHtml(feedbackText).replace(/\n/g, '<br>');
          aiContainer.innerHTML = '<strong>AI Feedback:</strong><br>' + safe;
        }
        // Persist the AI feedback to Firestore so it is visible to all users
        try {
          await updateDoc(doc(db, 'essays', docId), { aiFeedback: feedbackText });
        } catch (updateErr) {
          console.error('Error saving AI feedback:', updateErr);
        }
      } catch (err) {
        console.error('AI feedback error:', err);
        if (aiContainer) {
          aiContainer.textContent = 'Error retrieving AI feedback. Please try again later.';
        }
      } finally {
        // Re-enable the feedback button so the user can request feedback again.
        if (aiBtn) {
          aiBtn.disabled = false;
          aiBtn.textContent = 'Get AI Feedback';
          // Once feedback has been retrieved, hide the button entirely.  This
          // prevents multiple requests and cleans up the UI. If you wish to
          // allow multiple feedback requests, remove the following line.
          aiBtn.style.display = 'none';
        }
      }
    }

    /**
     * Safely convert various Firestore date representations into a Date
     * object. Supports Firestore Timestamp objects, numeric timestamps,
     * ISO strings or locale strings. If the value is invalid or missing,
     * the Unix epoch (1970-01-01) is returned.
     * @param {any} value
     * @returns {Date}
     */
    function toDateSafe(value) {
      try {
        if (!value) return new Date(0);
        // Firestore Timestamp object
        if (typeof value === 'object' && value.seconds !== undefined) {
          return new Date(value.seconds * 1000);
        }
        // Numeric timestamp (milliseconds)
        if (typeof value === 'number') {
          return new Date(value);
        }
        // Attempt to parse string formats
        const parsed = Date.parse(value);
        if (!isNaN(parsed)) {
          return new Date(parsed);
        }
      } catch (err) {
        console.warn('toDateSafe error for value', value, err);
      }
      return new Date(0);
    }

    /**
     * Strip HTML tags from a string.  This helper extracts the text content
     * from markup so that search queries can match plain text inside
     * essays without being affected by embedded HTML tags or formatting.
     * @param {string} html The HTML string to strip
     * @returns {string} Plain text
     */
    function stripHtml(html) {
      if (!html) return '';
      // Create a temporary DOM element and assign the HTML to its innerHTML.
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || '';
    }

    /**
     * Format a Date into a consistent DD/MM/YYYY, HH:MM:SS string. This
     * function centralises date formatting so that all dates displayed in
     * the UI follow the same locale-independent format.
     * @param {Date} date
     * @returns {string}
     */
    function formatDate(date) {
      const formatter = new Intl.DateTimeFormat('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
      return formatter.format(date);
    }

    // Firebase configuration (copied from the original)
    const firebaseConfig = {
      apiKey: "AIzaSyBnmbg7CyLki-M1E4rxPevJ741yTykliDA",
      authDomain: "pangeya-essay.firebaseapp.com",
      projectId: "pangeya-essay",
      storageBucket: "pangeya-essay.appspot.com",
      messagingSenderId: "783326121302",
      appId: "1:783326121302:web:7d73c5110fb5682e5fdaf7",
      measurementId: "G-0L1X6WHT1E"
    };
    // Initialize Firebase and Firestore
    const app = initializeApp(firebaseConfig);
    getAnalytics(app);
    const db = getFirestore(app);
    const essaysRef = collection(db, "essays");

    // Expose Firestore instance and helpers globally so that non‚Äëmodule
    // scripts (such as the hero animation script) can access them.  By
    // assigning these values to the window object, we avoid having to
    // re‚Äëimport Firestore modules in other scripts.  Only the functions
    // needed for hero editing are exposed: db, doc, getDoc and setDoc.
    window.db = db;
    window.firestoreDoc = doc;
    window.firestoreGetDoc = getDoc;
    window.firestoreSetDoc = setDoc;
    // Reference to the vocabulary collection for storing words and definitions
    // Vocabulary collection reference removed because vocabulary feature is deprecated.

    // Gift message features removed; no giftMessages collection or helpers.

    /**
     * Escape HTML special characters to prevent XSS when rendering content from
     * Firestore.  This helper extracts the text content and escapes characters.
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Render essays from Firestore into the list.  This function builds each
     * essay card including word count and optional feedback.  Positioning is
     * preserved from the original; we simply assign a class and rely on CSS for
     * the New Year sticker on each card.  Comment features have been removed.
     */
    async function renderEssays(queryName = '', showLatestOnly = false) {
      const container = document.getElementById('essaysList');
      // Increment the request counter and capture this call's id.
      const myRequestId = ++essayRequestCounter;
      container.innerHTML = '';
      const snapshot = await getDocs(essaysRef);
      // If a more recent request has been made, abort this render.
      if (myRequestId !== essayRequestCounter) {
        return;
      }
      if (snapshot.empty) {
        container.innerHTML =
          '<div style="font-size:12px;color:var(--text-muted);padding:2px 2px 6px;">No essays yet. Write and submit your first essay!</div>';
        allEssays = [];
        return;
      }
      const docsArray = [];
      snapshot.forEach(docSnap => {
        docsArray.push({ id: docSnap.id, data: docSnap.data() });
      });
      // Update global allEssays state.
      allEssays = docsArray;
      const parseDateString = (str) => {
        if (!str) return 0;
        const parts = str.split(',');
        const datePart = parts[0].trim();
        const timePart = parts[1] ? parts[1].trim() : '';
        let day, month, year;
        if (datePart.includes('.')) {
          [day, month, year] = datePart.split('.');
        } else if (datePart.includes('/')) {
          const dp = datePart.split('/');
          if (parseInt(dp[0], 10) > 12) {
            [day, month, year] = dp;
          } else {
            [month, day, year] = dp;
          }
        } else if (datePart.includes('-')) {
          const dp = datePart.split('-');
          if (dp[0].length === 4) {
            [year, month, day] = dp;
          } else {
            [month, day, year] = dp;
          }
        } else {
          return 0;
        }
        let hours = 0, minutes = 0, seconds = 0;
        if (timePart) {
          const tp = timePart.split(':');
          hours = parseInt(tp[0], 10) || 0;
          minutes = parseInt(tp[1], 10) || 0;
          seconds = parseInt(tp[2], 10) || 0;
        }
        const y = parseInt(year, 10);
        const m = parseInt(month, 10) - 1;
        const d = parseInt(day, 10);
        return new Date(y, m, d, hours, minutes, seconds).getTime();
      };
      // Optionally filter by author name if a search query was provided.
      const qName = (queryName || '').toString().trim().toLowerCase();
      let filteredArray = allEssays;
      if (qName) {
        // When a search query is provided, match it against the author's name
        // and the plain text of the essay.  We strip HTML tags from the
        // essay content so that search terms can match the visible text.
        filteredArray = allEssays.filter(item => {
          const nm = (item.data.name || '').toString().toLowerCase();
          const essayText = stripHtml(item.data.essay || '').toLowerCase();
          return nm.includes(qName) || essayText.includes(qName);
        });
      }
      // Sort descending by timestamp/date using safe conversion
      filteredArray.sort((a, b) => {
        const tA = toDateSafe(a.data.timestamp ?? a.data.date).getTime();
        const tB = toDateSafe(b.data.timestamp ?? b.data.date).getTime();
        return tB - tA;
      });
      // If no search query and we only want the most recent essay, slice the array
      if (!qName && showLatestOnly && filteredArray.length > 0) {
        filteredArray = [filteredArray[0]];
      }
      for (const item of filteredArray) {
        // Abort if this render is stale.  If a newer renderEssays() call
        // has updated essayRequestCounter, we stop building to prevent
        // mixing old and new data.
        if (myRequestId !== essayRequestCounter) {
          return;
        }
        const data = item.data;
        const docId = item.id;
        const card = document.createElement('div');
        card.className = 'essay-card';
        // Header with name and date
        const header = document.createElement('div');
        header.className = 'essay-header';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'essay-name';
        // Display the author's name or 'Unknown' without decorative emoji
        nameSpan.textContent = (data.name ? data.name : 'Unknown');
        const dateSpan = document.createElement('span');
        // Always compute and display the date using our helper functions.
        const displayDate = formatDate(toDateSafe(data.timestamp ?? data.date));
        dateSpan.textContent = displayDate;
        header.appendChild(nameSpan);
        header.appendChild(dateSpan);
        // Essay text
        const textDiv = document.createElement('div');
        textDiv.className = 'essay-text';
        textDiv.innerHTML = data.essay || '';
        card.appendChild(header);
        card.appendChild(textDiv);
        // Word count
        const rawText = textDiv.textContent || '';
        const wordsArray = rawText.trim().split(/\s+/).filter(word => word.length > 0);
        const wordCount = wordsArray.length;
        const wordCountDiv = document.createElement('div');
        wordCountDiv.className = 'word-count';
        wordCountDiv.style.fontSize = '12px';
        wordCountDiv.style.color = 'var(--text-muted)';
        wordCountDiv.style.marginBottom = '4px';
        wordCountDiv.textContent = `Word count: ${wordCount}`;
        card.appendChild(wordCountDiv);
        // Gift message (Valentine's message).  If a giftMessage field exists
        // on the document, display it with a heart icon.  Use escapeHtml to
        // prevent injection of HTML code.  Messages are optional.
        if (data.giftMessage && data.giftMessage.trim() !== '') {
          const giftDiv = document.createElement('div');
          giftDiv.className = 'gift-message';
          const heartSpan = document.createElement('span');
          heartSpan.className = 'valentine-sticker';
          heartSpan.textContent = 'üíå';
          giftDiv.appendChild(heartSpan);
          const msgSpan = document.createElement('span');
          msgSpan.innerHTML = escapeHtml(data.giftMessage);
          giftDiv.appendChild(msgSpan);
          card.appendChild(giftDiv);
        }
        // Feedback block
        if (data.feedback) {
          // Use a collapsible <details> element for teacher feedback so users can expand/collapse long feedback.
          const detailsEl = document.createElement('details');
          detailsEl.className = 'feedback feedback-details';
          const summaryEl = document.createElement('summary');
          summaryEl.textContent = 'Teacher Feedback';
          detailsEl.appendChild(summaryEl);
          const lines = data.feedback.split('\n');
          const formattedLines = lines.map(line => {
            const trimmed = line.trim();
            if (trimmed.startsWith('‚úî')) {
              const content = trimmed.substring(1).trim();
              return '<span class="fb-check">' + escapeHtml(content) + '</span>';
            } else if (trimmed.startsWith('‚úò')) {
              const content = trimmed.substring(1).trim();
              return '<span class="fb-cross">' + escapeHtml(content) + '</span>';
            }
            return escapeHtml(line);
          });
          const contentDiv = document.createElement('div');
          contentDiv.innerHTML = formattedLines.join('<br>');
          detailsEl.appendChild(contentDiv);
          card.appendChild(detailsEl);
        }
        // Action buttons
        const actions = document.createElement('div');
        actions.className = 'essay-actions';
        const editBtn = document.createElement('button');
        editBtn.className = 'chip-btn chip-edit';
        editBtn.textContent = 'Edit';
        editBtn.onclick = () => openEditModal(docId, data);
        const delBtn = document.createElement('button');
        delBtn.className = 'chip-btn chip-delete';
        delBtn.textContent = 'Delete';
        delBtn.onclick = () => deleteEssay(docId);
        delBtn.style.display = teacherMode ? 'inline-block' : 'none';
        const fbBtn = document.createElement('button');
        fbBtn.className = 'chip-btn chip-feedback';
        fbBtn.textContent = 'Add/Edit Feedback';
        fbBtn.style.display = teacherMode ? 'inline-block' : 'none';
        fbBtn.onclick = () => openFeedbackModal(docId, data);
        actions.appendChild(editBtn);
        actions.appendChild(delBtn);
        actions.appendChild(fbBtn);
        // Add AI feedback button for each essay.  Users can click this
        // button to request AI feedback on that specific essay.  A unique
        // id is assigned so the button can be disabled after use.
        const aiBtn = document.createElement('button');
        aiBtn.className = 'chip-btn chip-feedback';
        aiBtn.textContent = 'Get AI Feedback';
        aiBtn.id = 'aiFeedbackBtn-' + docId;
        aiBtn.onclick = () => getEssayAIFeedback(docId, data);
        // Hide AI feedback button if feedback already exists
        if (data.aiFeedback && data.aiFeedback.trim() !== '') {
          aiBtn.style.display = 'none';
        }
        actions.appendChild(aiBtn);
        // NEW: Add per-essay PDF download button
        const pdfBtn = document.createElement('button');
        pdfBtn.className = 'chip-btn chip-download';
        pdfBtn.textContent = 'Download PDF';
        pdfBtn.onclick = () => downloadEssayPDF(data);
        actions.appendChild(pdfBtn);
        card.appendChild(actions);
        // Placeholder for AI feedback.  Use a collapsible details element so users can toggle visibility.
        const aiFbDiv = document.createElement('details');
        aiFbDiv.className = 'ai-feedback ai-feedback-details';
        aiFbDiv.id = 'aiFeedback-' + docId;
        // Create summary as the clickable label
        const aiSummary = document.createElement('summary');
        aiSummary.textContent = 'AI Feedback';
        aiFbDiv.appendChild(aiSummary);
        // Create content container for the AI feedback
        const aiContent = document.createElement('div');
        // If this essay already has AI feedback saved in Firestore, display it immediately.
        if (data.aiFeedback && data.aiFeedback.trim() !== '') {
          const safeAi = escapeHtml(data.aiFeedback).replace(/\n/g, '<br>');
          aiContent.innerHTML = safeAi;
        } else {
          // Hide the details element until feedback is fetched
          aiFbDiv.classList.add('hidden');
        }
        aiFbDiv.appendChild(aiContent);
        card.appendChild(aiFbDiv);
        // Gift message and decorative card sticker removed

        container.appendChild(card);
      }
    }

    /**
     * Handle essay search initiated by the user.  This helper reads the
     * contents of the search input and calls renderEssays with the
     * provided query.  If the input is empty, all essays are shown.
     */
        function searchEssays() {
          const input = document.getElementById('essaySearch');
          const query = input ? input.value.trim() : '';
          // When the query is empty, show the full list of essays.  Otherwise
          // filter by the query.  The second parameter is left as default
          // (false) so that renderEssays shows all when empty.
          renderEssays(query);
        }

    /** Submit a new essay to Firestore */
    async function submitEssay() {
      const nameInput = document.getElementById('name');
      const essayInput = document.getElementById('essay');
      const name = nameInput.value.trim();
      const essay = essayInput.value.trim();
      if (!essay) {
        alert('Please write an essay before submitting.');
        return;
      }
      // Capture current time once to ensure date and timestamp match
      const now = new Date();
      const giftMsgInput = document.getElementById('giftMessage');
      const giftMessage = giftMsgInput ? giftMsgInput.value.trim() : '';
      await addDoc(essaysRef, {
        name: name || 'Unknown',
        essay: essay,
        date: formatDate(now),
        timestamp: now.getTime(),
        feedback: '',
        giftMessage: giftMessage
      });
      renderEssays();
      essayInput.value = '';
      if (giftMsgInput) giftMsgInput.value = '';
      nameInput.value = '';
      alert('Essay saved to the cloud.');
    }

    // Edit modal handlers
    async function openEditModal(docId, data) {
      currentEditId = docId;
      const editArea = document.getElementById('editArea');
      editArea.innerHTML = data.essay || '';
      // Populate the gift message input with existing value (if any)
      const giftEditInput = document.getElementById('giftMessageEdit');
      if (giftEditInput) {
        giftEditInput.value = data.giftMessage || '';
      }
      document.getElementById('editModal').style.display = 'flex';
    }
    function closeEditModal() {
      document.getElementById('editModal').style.display = 'none';
      currentEditId = null;
    }
    async function saveEdit() {
      if (!currentEditId) return;
      const updated = document.getElementById('editArea').innerHTML;
      const giftEditInput = document.getElementById('giftMessageEdit');
      const giftMsg = giftEditInput ? giftEditInput.value.trim() : '';
      // Save the updated essay text and gift message
      await updateDoc(doc(db, 'essays', currentEditId), {
        essay: updated,
        giftMessage: giftMsg
      });
      // Re-render essays to update messages
      await renderEssays();
      closeEditModal();
    }

    // Feedback modal handlers
    function openFeedbackModal(docId, data) {
      currentFeedbackId = docId;
      document.getElementById('feedbackArea').value = data.feedback || '';
      const essayDiv = document.getElementById('feedbackEssay');
      essayDiv.innerHTML = data.essay || '';
      document.getElementById('feedbackModal').style.display = 'flex';
    }
    function closeFeedbackModal() {
      document.getElementById('feedbackModal').style.display = 'none';
      currentFeedbackId = null;
    }
    async function saveFeedback() {
      if (!currentFeedbackId) return;
      const updated = document.getElementById('feedbackArea').value;
      const essayUpdated = document.getElementById('feedbackEssay').innerHTML;
      await updateDoc(doc(db, 'essays', currentFeedbackId), { feedback: updated, essay: essayUpdated });
      renderEssays();
      closeFeedbackModal();
    }

    /** Delete an essay */
    async function deleteEssay(docId) {
      if (!confirm('Delete this essay?')) return;
      await deleteDoc(doc(db, 'essays', docId));
      renderEssays();
    }

    // Rich text formatting commands for the edit and feedback modals
    function findTagParent(node, tagNames, editableParent) {
      while (node && node !== editableParent) {
        if (node.nodeType === 1) {
          const nodeName = node.nodeName.toLowerCase();
          if (tagNames.includes(nodeName)) {
            return node;
          }
          if (node.classList) {
            if (tagNames.includes('mark') && node.classList.contains('user-highlight')) return node;
            if (tagNames.includes('u') && node.classList.contains('underline-text')) return node;
            if (tagNames.includes('s') && node.classList.contains('strike-text')) return node;
          }
        }
        node = node.parentNode;
      }
      return null;
    }
    function getEditableParent(sel) {
      if (!sel.rangeCount) return null;
      const range = sel.getRangeAt(0);
      let containerNode = range.commonAncestorContainer;
      let editableParent = null;
      if (containerNode.nodeType === 1) {
        editableParent = containerNode.closest('[contenteditable="true"]');
      } else {
        editableParent = containerNode.parentElement ? containerNode.parentElement.closest('[contenteditable="true"]') : null;
      }
      if (!editableParent || (editableParent.id !== 'editArea' && editableParent.id !== 'feedbackEssay')) return null;
      return editableParent;
    }
    function highlightSelection() {
      const sel = window.getSelection();
      const editableParent = getEditableParent(sel);
      if (!editableParent) return;
      editableParent.focus();
      const selectedText = sel.toString();
      if (!selectedText) return;
      let markParent = findTagParent(sel.anchorNode, ['mark'], editableParent) || findTagParent(sel.focusNode, ['mark'], editableParent);
      if (markParent) {
        const text = markParent.textContent;
        markParent.replaceWith(document.createTextNode(text));
      } else {
        const markHtml = `<mark>${selectedText}</mark>`;
        document.execCommand('insertHTML', false, markHtml);
      }
    }
    function underlineSelection() {
      const sel = window.getSelection();
      const editableParent = getEditableParent(sel);
      if (!editableParent) return;
      editableParent.focus();
      const selectedText = sel.toString();
      if (!selectedText) return;
      let underlineParent = findTagParent(sel.anchorNode, ['u'], editableParent) || findTagParent(sel.focusNode, ['u'], editableParent);
      if (underlineParent) {
        const text = underlineParent.textContent;
        underlineParent.replaceWith(document.createTextNode(text));
      } else {
        const uHtml = `<u>${selectedText}</u>`;
        document.execCommand('insertHTML', false, uHtml);
      }
    }
    function strikeSelection() {
      const sel = window.getSelection();
      const editableParent = getEditableParent(sel);
      if (!editableParent) return;
      editableParent.focus();
      const selectedText = sel.toString();
      if (!selectedText) return;
      let strikeParent = findTagParent(sel.anchorNode, ['s'], editableParent) || findTagParent(sel.focusNode, ['s'], editableParent);
      if (strikeParent) {
        const text = strikeParent.textContent;
        strikeParent.replaceWith(document.createTextNode(text));
      } else {
        const sHtml = `<s>${selectedText}</s>`;
        document.execCommand('insertHTML', false, sHtml);
      }
    }

    // Teacher panel toggling
    function toggleTeacherPanel() {
      const panel = document.getElementById('teacherPanel');
      panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
    }
    function enterTeacherMode() {
      const key = document.getElementById('teacherKey').value.trim();
      if (!key) {
        alert('Enter teacher key.');
        return;
      }
      if (key === TEACHER_KEY) {
        teacherMode = true;
        alert('Teacher mode enabled.');
        document.getElementById('teacherKey').value = '';
        document.getElementById('teacherPanel').style.display = 'none';
        renderEssays();
      } else {
        alert('Wrong key.');
      }
    }

    /**
     * Theme switching ‚Äì extended from the original to support multiple themes.
     * Supports only Light and Dark themes.  The previous Neon and Pangeya
     * themes have been removed.  Active button styling is updated accordingly.
     * If an unknown theme is passed, Dark will be selected by default.
     */
    function setTheme(theme) {
      const body = document.body;
      // Remove any previously applied theme classes.  Glass theme is defined
      // but unused by default; if you add a glass theme toggle in the UI,
      // include 'glass-theme' here as well.  Neon and Pangeya themes are no longer supported.
      body.classList.remove('light-theme', 'dark-theme');
      // Reset active states on available theme buttons
      document.getElementById('lightTheme').classList.remove('active');
      document.getElementById('darkTheme').classList.remove('active');
      // Duplicate theme buttons in vocabulary/chat sections do not exist in this
      // version, but we defensively query them and remove their active class if present.
      // On the current version there are no duplicate theme buttons in vocabulary/chat sections.
      // The variables neonV, lightV and darkV referenced in the original implementation have been removed.
      if (theme === 'light') {
        body.classList.add('light-theme');
        document.getElementById('lightTheme').classList.add('active');
        // There is only one set of theme buttons; no additional buttons to update.
      } else if (theme === 'dark') {
        body.classList.add('dark-theme');
        document.getElementById('darkTheme').classList.add('active');
        // There is only one set of theme buttons; no additional buttons to update.
      } else {
        // Fallback to dark theme as default
        body.classList.add('dark-theme');
        document.getElementById('darkTheme').classList.add('active');
        // There is only one set of theme buttons; no additional buttons to update.
      }
    }

    /**
     * PDF download via jsPDF.  Retains the behaviour of the original site.
     */
    async function downloadPDF() {
      const { jsPDF } = window.jspdf;
      const docPDF = new jsPDF({ unit: 'pt', format: 'a4' });
      let name = document.getElementById('name').value.trim();
      let essay = document.getElementById('essay').value.trim();
      if (!name || !essay) {
        const snapshot = await getDocs(essaysRef);
        const docsList = snapshot.docs;
        if (docsList.length) {
          const last = docsList[docsList.length - 1].data();
          if (!name) name = last.name || 'Unknown';
          if (!essay) essay = last.essay || '';
        }
      }
      if (!essay) {
        alert('There is no essay text to export.');
        return;
      }
      if (!name) name = 'Unknown';
      docPDF.setFontSize(22);
      docPDF.setTextColor(140, 0, 255);
      docPDF.text('Pangeya Essay Report', 40, 50);
      docPDF.setFontSize(12);
      docPDF.setTextColor(0, 0, 0);
      docPDF.text('Name: ' + name, 40, 90);
      // Use consistent date formatting in the exported PDF
      const nowPDF = new Date();
      docPDF.text('Date: ' + formatDate(nowPDF), 40, 110);
      docPDF.setFontSize(14);
      docPDF.setTextColor(30, 30, 30);
      docPDF.text('Essay:', 40, 150);
      const lines = docPDF.splitTextToSize(essay, 520);
      docPDF.text(lines, 40, 180);
      docPDF.save('pangeya-essay.pdf');
    }

    /**
     * Download a single essay as a PDF. Accepts an essay data object containing
     * name, essay, and timestamp/date. This helper is used for the per-essay
     * download buttons in the essay list.
     * @param {Object} essayData
     */
    async function downloadEssayPDF(essayData) {
      const { jsPDF } = window.jspdf;
      const docPDF = new jsPDF({ unit: 'pt', format: 'a4' });
      // Determine name and fallback if needed
      let name = (essayData && essayData.name ? essayData.name.trim() : '') || 'Unknown';
      const essayHtml = (essayData && essayData.essay) ? essayData.essay : '';
      const essayText = stripHtml(essayHtml);
      // Determine a date string from timestamp or date fields
      let dateObj;
      if (essayData && (essayData.timestamp !== undefined && essayData.timestamp !== null)) {
        dateObj = toDateSafe(essayData.timestamp);
      } else {
        dateObj = toDateSafe(essayData && essayData.date ? essayData.date : null);
      }
      const dateStr = formatDate(dateObj);
      docPDF.setFontSize(22);
      docPDF.setTextColor(140, 0, 255);
      docPDF.text('Pangeya Essay Report', 40, 50);
      docPDF.setFontSize(12);
      docPDF.setTextColor(0, 0, 0);
      docPDF.text('Name: ' + name, 40, 90);
      docPDF.text('Date: ' + dateStr, 40, 110);
      docPDF.setFontSize(14);
      docPDF.setTextColor(30, 30, 30);
      docPDF.text('Essay:', 40, 150);
      const lines = docPDF.splitTextToSize(essayText, 520);
      docPDF.text(lines, 40, 180);
      // Build a safe filename
      const safeName = name.replace(/[^a-z0-9]+/gi, '_').toLowerCase() || 'essay';
      docPDF.save(safeName + '_essay.pdf');
    }

    // Info and guide modals toggling
    function toggleInfoModal() {
      const infoModal = document.getElementById('infoModal');
      if (!infoModal) return;
      infoModal.style.display = infoModal.style.display === 'flex' ? 'none' : 'flex';
    }
    window.toggleInfoModal = toggleInfoModal;
    function toggleGuideModal() {
      const guideModal = document.getElementById('guideModal');
      if (!guideModal) return;
      guideModal.style.display = guideModal.style.display === 'flex' ? 'none' : 'flex';
    }
    window.toggleGuideModal = toggleGuideModal;

    // Keyboard shortcuts to open modals
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === ';') {
        e.preventDefault();
        e.stopPropagation();
        toggleGuideModal();
        return;
      }
      if ((e.ctrlKey || e.metaKey) && e.key === '`') {
        e.preventDefault();
        e.stopPropagation();
        toggleInfoModal();
        return;
      }
    });
    // Close modals when clicking outside content
    window.addEventListener('click', (e) => {
      const editM = document.getElementById('editModal');
      const fbM = document.getElementById('feedbackModal');
      if (e.target === editM) closeEditModal();
      if (e.target === fbM) closeFeedbackModal();
      const infoM = document.getElementById('infoModal');
      const guideM = document.getElementById('guideModal');
      if (e.target === infoM) toggleInfoModal();
      if (e.target === guideM) toggleGuideModal();
    });

    // Event listeners for main controls
    document.getElementById('submitBtn').addEventListener('click', submitEssay);
    document.getElementById('pdfBtn').addEventListener('click', downloadPDF);
    document.getElementById('teacherToggle').addEventListener('click', toggleTeacherPanel);
    document.getElementById('teacherEnter').addEventListener('click', enterTeacherMode);
    document.getElementById('lightTheme').addEventListener('click', () => setTheme('light'));
    document.getElementById('darkTheme').addEventListener('click', () => setTheme('dark'));

    // Pangeya theme button has been removed.  Previously there was a handler
    // attached to the Pangeya button to select the green palette.  Since
    // the Pangeya theme is deprecated, this code has been omitted.

    // Search input events: update essay list as the user types or clears the search
    const essaySearchInput = document.getElementById('essaySearch');
    if (essaySearchInput) {
      // Re-render essays on every input change (typing or clearing)
      essaySearchInput.addEventListener('input', () => {
        searchEssays();
      });
      // Also allow pressing Enter to trigger the search explicitly
      essaySearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          searchEssays();
        }
      });
    }

    // New Year and weather effects removed

    // Initial render
    renderEssays();

    // Vocabulary removed: no need to render vocabulary list

    // =============================================
    // Vocabulary module
    // Functions and event bindings for the vocabulary section are defined below.

    // Vocabulary section has been removed; switchToVocab is deprecated.

    // Return to the essay section from the vocabulary section
    function switchToEssays() {
      const essaySection = document.getElementById('essaySection');
      if (essaySection) {
        essaySection.style.display = 'block';
      }
      // Hide chat section when returning to essays
      const chatSection = document.getElementById('chatSection');
      if (chatSection) {
        chatSection.style.display = 'none';
      }
    }

    // Vocabulary rendering function removed; returns immediately.
    async function renderVocab() {
      return;
    }

    // Vocabulary add function removed; no operation performed.
    async function addVocab() {
      return;
    }

    // Vocabulary search function removed.
    function searchVocab() {
      return;
    }

    // Vocabulary delete function removed.
    async function deleteVocab() {
      return;
    }

    // Vocabulary events removed.

    // Bind chat events
    document.getElementById('chatSendBtn')?.addEventListener('click', sendChatMessage);
    const chatInputEl = document.getElementById('chatInput');
    if (chatInputEl) {
      chatInputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendChatMessage();
        }
      });
    }
    // There is no chat back button in this version; navigation is handled by the UI.
    // Bind image upload button: triggers the hidden file input click
    // Image upload functionality has been removed from the chat.  No button binding is necessary.
    // The image input is no longer present; no change listener is needed.
    // Bind clear chat button
    const chatClearBtnEl = document.getElementById('chatClearBtn');
    if (chatClearBtnEl) {
      chatClearBtnEl.addEventListener('click', (e) => {
        e.preventDefault();
        clearChat();
      });
    }

    // Per-essay AI feedback buttons are added dynamically for each essay card; there is no global feedback button.

    // Initialize chat credits display
    updateChatCredit();

    // Hide legacy sticker images for buttons and cards in case CSS fails to override.
    // We prefer using emoji-based stickers instead of the old base64 images.
    document.querySelectorAll('.btn-sticker, .card-sticker').forEach(el => {
      el.style.display = 'none';
    });
    // Expose modal functions for inline handlers
    window.openEditModal = openEditModal;
    window.closeEditModal = closeEditModal;
    window.saveEdit = saveEdit;
    window.openFeedbackModal = openFeedbackModal;
    window.closeFeedbackModal = closeFeedbackModal;
    window.saveFeedback = saveFeedback;
    // Expose formatting functions
    window.highlightSelection = highlightSelection;
    window.underlineSelection = underlineSelection;
    window.strikeSelection = strikeSelection;

    // Expose AI feedback helper so inline event handlers can call it
    window.getEssayAIFeedback = getEssayAIFeedback;
    // Comment functions are removed; no need to expose them.

    // Expose section switching functions globally so inline HTML
    // onclick handlers can invoke them.
    window.switchToEssays = switchToEssays;
    // Weather toggle removed; nothing to expose
    // Expose PDF functions to ensure they are globally accessible in case inline attributes are used
    window.downloadPDF = downloadPDF;
    window.downloadEssayPDF = downloadEssayPDF;
  </script>

  <!-- Particle text animation script.  The logic below implements a
       particle‚Äëbased text effect directly within this HTML file.  It
       renders the word "Pangea" using hundreds of small square particles
       that assemble from random positions into the target shape.  The
       animation is responsive, recalculates on resize, and includes a
       subtle mouse repelling effect.  Constants such as PARTICLE_GAP,
       EASE and FRICTION can be tweaked to modify behaviour. -->
  <script>
    /*
      Inlined pixel animation script

      This script implements a simple particle‚Äëbased text animation for the word
      "Pangea".  It uses an HTML5 canvas element contained within a
      `.pixel‚Äëhero` wrapper to render hundreds of small square particles.  The
      particles start at random positions on the canvas and ease into their
      destination positions, which are determined by sampling pixel data from an
      off‚Äëscreen canvas where the word is rendered in the chosen font.

      Key features:
      - Responsive: the canvas resizes with its container and recomputes
        particles on resize events.
      - Staggered assembly: each particle has a random delay before it begins
        moving, creating a cascading reveal effect.
      - Mouse interaction: moving the cursor across the canvas causes nearby
        particles to repel slightly, adding a subtle interactive feel.

      The animation is self‚Äëcontained and does not rely on any external
      libraries.  It is safe to include alongside other scripts on the page
      without interfering with global variables.  To modify behaviour, you may
      adjust the constants such as `PARTICLE_GAP`, `EASE`, and `FRICTION` below.
    */
    (() => {
      // Wait for the DOM to be fully parsed before querying elements.
      document.addEventListener('DOMContentLoaded', () => {
        const heroContainer = document.querySelector('.pixel-hero');
        const canvas = document.getElementById('pixelCanvas');
        // Fallback element for small screens
        const fallbackEl = heroContainer ? heroContainer.querySelector('#pixelFallback') : null;
        if (!heroContainer || !canvas) {
          // The hero container or canvas is not present; abort initialization.
          return;
        }
        const ctx = canvas.getContext('2d');

        // Apply any saved hero customisations to the heading and subtitle.
        // First attempt to load values from localStorage so that users
        // without network connectivity still see their last edits.  These
        // will later be overridden by values loaded from Firestore (if
        // available) to ensure all users see the same hero content.
        const savedTitle = localStorage.getItem('pangeya_hero_title');
        const savedSubtitle = localStorage.getItem('pangeya_hero_subtitle');
        const titleElement = document.getElementById('heroTitle');
        const subtitleElement = document.getElementById('heroSubtitle');
        if (savedTitle && titleElement) {
          titleElement.textContent = savedTitle;
        }
        if (savedSubtitle && subtitleElement) {
          subtitleElement.textContent = savedSubtitle;
        }

        /**
         * Load hero settings from Firestore.  If a document exists at
         * siteSettings/hero it contains the shared hero title, subtitle and
         * particleText.  When found, these values override any local
         * customisations and the particle animation is regenerated.  This
         * function is executed asynchronously on page load to keep the UI
         * responsive while retrieving data from the network.
         */
        async function loadHeroFromFirestore() {
          try {
            // Ensure Firestore helpers are available (they are exposed on
            // window by the Firebase module script).  If not found, abort.
            if (!window.db || !window.firestoreDoc || !window.firestoreGetDoc) {
              return;
            }
            const heroDocRef = window.firestoreDoc(window.db, 'siteSettings', 'hero');
            const heroSnap = await window.firestoreGetDoc(heroDocRef);
            if (heroSnap.exists()) {
              const data = heroSnap.data();
              // Apply Firestore values if they exist.
              if (data.title && titleElement) {
                titleElement.textContent = data.title;
                localStorage.setItem('pangeya_hero_title', data.title);
              }
              if (data.subtitle && subtitleElement) {
                subtitleElement.textContent = data.subtitle;
                localStorage.setItem('pangeya_hero_subtitle', data.subtitle);
              }
              if (data.particleText) {
                particleText = data.particleText;
                localStorage.setItem('pangeya_particle_text', data.particleText);
                // Regenerate particles to reflect the new text.
                generateParticles();
              }
            }
          } catch (err) {
            console.error('Error loading hero settings from Firestore:', err);
          }
        }

        /**
         * Persist hero settings to Firestore.  Accepts an object containing
         * any of the keys: title, subtitle and particleText.  These values
         * are merged into the existing document at siteSettings/hero.
         * Using merge:true ensures we do not overwrite other fields if
         * present in the document.  Errors are logged to the console.
         *
         * @param {Object} updates  Partial hero settings to save
         */
        async function saveHeroToFirestore(updates) {
          try {
            if (!window.db || !window.firestoreDoc || !window.firestoreSetDoc) {
              return;
            }
            const heroDocRef = window.firestoreDoc(window.db, 'siteSettings', 'hero');
            await window.firestoreSetDoc(heroDocRef, updates, { merge: true });
          } catch (err) {
            console.error('Error saving hero settings to Firestore:', err);
          }
        }

        // Immediately load shared hero settings from Firestore.  This call
        // runs after localStorage values have been applied so that remote
        // values override any local edits.
        loadHeroFromFirestore();

        // Create an off‚Äëscreen canvas for drawing the text and sampling pixels.
        const offCanvas = document.createElement('canvas');
        const offCtx = offCanvas.getContext('2d');

        // Secret key and dynamic text for the hero animation.
        // Change HERO_EDIT_KEY to your own secret value to restrict who can
        // modify the hero heading, subtitle and particle text.  The
        // `particleText` variable holds the word that will be rendered by
        // the particle animation; it defaults to "Pangea" but can be
        // updated via the secret editing prompt.  This value may be
        // overridden by data loaded from Firestore.
        const HERO_EDIT_KEY = 'changeme';
        // The word rendered by the particle animation.  Attempt to load a
        // previously saved value from localStorage so that customisations
        // persist across sessions.  If none is found, fall back to the
        // default "Pangea".
        let particleText = localStorage.getItem('pangeya_particle_text') || 'Pangea';

        // Array to hold all particle objects.
        let particles = [];

        // Mouse state for interactive repelling; values are set on mousemove.
        const mouse = { x: null, y: null, radius: 80 };

        // Tuning constants
        // Particle behaviour tuning constants.  These values are updated
        // dynamically in resizeCanvas() based on the canvas width.  Larger
        // screens use a smaller gap and slower ease for smoother motion,
        // whereas small screens increase the gap and ease so that the
        // animation completes quickly and efficiently on mobile devices.
        let PARTICLE_GAP = 4;    // distance between sampled pixels (affects particle count)
        let EASE = 0.02;         // how quickly particles accelerate towards their destination
        const FRICTION = 0.9;    // damping factor applied to velocities
        let MAX_DELAY = 60;      // maximum initial delay (in frames) before a particle starts moving

        /**
         * Resize both the visible and off‚Äëscreen canvases to match the hero
         * container dimensions.  Called on load and whenever the window is
         * resized.  Also recalculates particles to maintain crisp text.
         */
        function resizeCanvas() {
          const rect = heroContainer.getBoundingClientRect();
          // Set canvas dimensions to match the container's width and height.
          // Resize canvases to match the hero container dimensions
          canvas.width = rect.width;
          canvas.height = rect.height;
          offCanvas.width = rect.width;
          offCanvas.height = rect.height;

          // Determine whether to show the canvas animation or a simple
          // fallback text based on the available width.  For very
          // narrow screens (e.g. mobile phones), the pixel animation
          // becomes difficult to read and can perform poorly.  In that
          // case we hide the canvas and display a text fallback instead.
          const useFallback = rect.width < 420;
          if (fallbackEl) {
            if (useFallback) {
              // Hide the canvas and show the fallback element
              canvas.style.display = 'none';
              fallbackEl.style.display = 'flex';
              // Set the fallback text to the current particle text
              fallbackEl.textContent = particleText;
              // Compute an appropriate font size so the text fits within
              // the container width.  Use the off-screen context to
              // measure the text width at an initial size and scale
              // down if necessary.
              let fallbackSize = rect.height * 0.6;
              offCtx.font = `${fallbackSize}px Poppins, sans-serif`;
              let metrics = offCtx.measureText(particleText);
              let textWidth = metrics.width;
              if (textWidth > rect.width * 0.9) {
                const scale = (rect.width * 0.9) / textWidth;
                fallbackSize *= scale;
              }
              fallbackEl.style.fontSize = `${fallbackSize}px`;
            } else {
              // Show the canvas and hide the fallback element
              canvas.style.display = 'block';
              fallbackEl.style.display = 'none';
            }
          }

          // Adjust particle gap, ease factor and maximum delay based on
          // canvas width.  On small screens we want fewer particles and
          // faster motion for better performance and responsiveness.
          if (rect.width < 420) {
            PARTICLE_GAP = 7;
            EASE = 0.05;
            MAX_DELAY = 25;
          } else if (rect.width < 700) {
            PARTICLE_GAP = 5;
            EASE = 0.035;
            MAX_DELAY = 40;
          } else {
            PARTICLE_GAP = 4;
            EASE = 0.02;
            MAX_DELAY = 60;
          }

          // Generate particles only if the canvas is visible.  If the
          // fallback is active, skip particle generation to save work.
          if (!useFallback) {
            generateParticles();
          }
        }

        /**
         * Draw the target text onto the off‚Äëscreen canvas and sample its pixels
         * to create particle objects for every visible pixel.  Each particle
         * stores its destination coordinates, a random starting position and
         * velocity, and a delay before it begins to move.
         */
        function generateParticles() {
          particles = [];
          const width = offCanvas.width;
          const height = offCanvas.height;
          // Clear the off‚Äëscreen canvas.
          offCtx.clearRect(0, 0, width, height);
          // Choose a base font size relative to the canvas height.  The factor
          // of 0.6 leaves vertical padding.  We will adjust this size if
          // the rendered text would overflow the canvas width.
          let fontSize = height * 0.6;
          offCtx.textAlign = 'center';
          offCtx.textBaseline = 'middle';
          const text = particleText;
          // Set an initial font and measure its width.
          offCtx.font = `${fontSize}px Poppins, sans-serif`;
          let metrics = offCtx.measureText(text);
          let textWidth = metrics.width;
          // If the text width exceeds 90% of the canvas width, scale the
          // font size down proportionally so that it fits.  This ensures
          // longer phrases remain visible on both mobile and desktop.
          if (textWidth > width * 0.9) {
            const scale = (width * 0.9) / textWidth;
            fontSize *= scale;
            offCtx.font = `${fontSize}px Poppins, sans-serif`;
            // Re-measure the text width after adjusting font size.
            metrics = offCtx.measureText(text);
            textWidth = metrics.width;
          }
          // Use the CSS variable --accent for the text fill colour to tie the
          // particle colours to the current theme.  Fallback to a magenta hue
          // if the variable is not defined.
          const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#a855f7';
          offCtx.fillStyle = accent.trim();
          offCtx.fillText(text, width / 2, height / 2);
          // Extract pixel data from the off‚Äëscreen canvas.
          const imgData = offCtx.getImageData(0, 0, width, height).data;
          // Loop through pixels at intervals defined by PARTICLE_GAP.  For each
          // non‚Äëtransparent pixel (alpha > threshold), create a particle whose
          // destination is that pixel's x and y coordinate.
          for (let y = 0; y < height; y += PARTICLE_GAP) {
            for (let x = 0; x < width; x += PARTICLE_GAP) {
              const index = (y * width + x) * 4;
              // Only consider pixels with significant alpha.  This ensures we
              // ignore background pixels.
              if (imgData[index + 3] > 128) {
                particles.push(new Particle(x, y, PARTICLE_GAP));
              }
            }
          }
        }

        /**
         * Particle constructor.  Each particle represents one pixel of the text.
         * @param {number} destX  Target x coordinate for the particle
         * @param {number} destY  Target y coordinate for the particle
         * @param {number} size   Size of the drawn square
         */
        class Particle {
          constructor(destX, destY, size) {
            this.destX = destX;
            this.destY = destY;
            // Start at a random position scattered around the canvas.  Y is
            // offset below the canvas to give the impression of particles
            // "falling" into place.  X spans the full width.
            this.x = Math.random() * canvas.width;
            this.y = canvas.height + Math.random() * canvas.height;
            this.size = size;
            this.vx = 0;
            this.vy = 0;
            // Random delay (in frames) before the particle begins to move.
            // Delay the start of motion by up to MAX_DELAY frames.  The
            // MAX_DELAY value is adjusted for small screens to ensure the
            // animation begins promptly on mobile devices.
            this.delay = Math.floor(Math.random() * MAX_DELAY);
          }
          /**
           * Update the particle's position.  Applies easing towards the
           * destination coordinates, friction to smooth the motion and a
           * repelling force if the mouse is nearby.
           */
          update() {
            if (this.delay > 0) {
              // Decrement delay and skip motion until delay has elapsed.
              this.delay--;
              return;
            }
            // Compute acceleration towards the destination.
            const dx = this.destX - this.x;
            const dy = this.destY - this.y;
            this.vx += dx * EASE;
            this.vy += dy * EASE;
            // Apply mouse repelling force if within radius.
            if (mouse.x !== null && mouse.y !== null) {
              const mx = this.x - mouse.x;
              const my = this.y - mouse.y;
              const dist = Math.hypot(mx, my);
              if (dist < mouse.radius && dist > 0) {
                const force = (mouse.radius - dist) / mouse.radius;
                const angle = Math.atan2(my, mx);
                // Multiply by a factor to increase the repelling strength.
                this.vx += Math.cos(angle) * force * 2;
                this.vy += Math.sin(angle) * force * 2;
              }
            }
            // Apply friction to dampen velocity and smooth the motion.
            this.vx *= FRICTION;
            this.vy *= FRICTION;
            this.x += this.vx;
            this.y += this.vy;
          }
          /**
           * Draw the particle as a small square on the main canvas.  The colour
           * is derived from the current accent CSS variable to ensure it adapts
           * to theme changes.
           */
          draw() {
            // Re‚Äëread the accent colour each frame in case the theme changes at
            // runtime.  Trim whitespace from computed property.
            const color = (getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#a855f7').trim();
            ctx.fillStyle = color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
          }
        }

        /**
         * Animation loop.  Clears the canvas, updates each particle and draws
         * them in their new positions.  Uses requestAnimationFrame for smooth
         * updates at the browser's refresh rate.
         */
        function animate() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.update();
            p.draw();
          }
          requestAnimationFrame(animate);
        }

        /**
         * Capture mouse coordinates relative to the canvas when moving.  On
         * mouseleave, reset the coordinates to null so that repelling forces
         * cease.
         */
        function attachMouseHandlers() {
          canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
          });
          canvas.addEventListener('mouseleave', () => {
            mouse.x = null;
            mouse.y = null;
          });
        }

        // Initial setup: size canvases, generate particles and start the loop.
        function init() {
          resizeCanvas();
          attachMouseHandlers();
          animate();
        }

        // Handle window resize by updating canvas sizes and regenerating particles.
        window.addEventListener('resize', () => {
          resizeCanvas();
        });

        // Kick things off.
        init();

        // Attach a secret editing handler.  Pressing Ctrl+Shift+E prompts
        // for the secret key defined by HERO_EDIT_KEY.  When the correct key
        // is entered, the user is asked to provide new values for the hero
        // heading, subtitle and particle animation text.  These changes take
        // effect immediately.  Incorrect keys result in an alert.
        document.addEventListener('keydown', async (e) => {
          // Only react to Ctrl+Shift+E (case-insensitive)
          if (e.ctrlKey && e.shiftKey && e.key && e.key.toLowerCase() === 'e') {
            e.preventDefault();
            const key = prompt('Enter secret key to edit hero:');
            if (key === HERO_EDIT_KEY) {
              const titleEl = document.getElementById('heroTitle');
              const subtitleEl = document.getElementById('heroSubtitle');
              // Prompt for new heading text
              const newTitle = prompt('Enter new heading text:', titleEl ? titleEl.textContent : '');
              let updates = {};
              if (newTitle !== null && titleEl) {
                titleEl.textContent = newTitle;
                localStorage.setItem('pangeya_hero_title', newTitle);
                updates.title = newTitle;
              }
              // Prompt for new subtitle text
              const newSubtitle = prompt('Enter new subtitle:', subtitleEl ? subtitleEl.textContent : '');
              if (newSubtitle !== null && subtitleEl) {
                subtitleEl.textContent = newSubtitle;
                localStorage.setItem('pangeya_hero_subtitle', newSubtitle);
                updates.subtitle = newSubtitle;
              }
              // Prompt for new particle text; empty input leaves it unchanged
              const newParticle = prompt('Enter new pixel animation text:', particleText);
              if (newParticle !== null && newParticle.trim() !== '') {
                particleText = newParticle;
                localStorage.setItem('pangeya_particle_text', newParticle);
                updates.particleText = newParticle;
                // Update the display: regenerate particles or fallback via resizeCanvas
                resizeCanvas();
              }
              // Save updates to Firestore if any fields were modified.
              if (Object.keys(updates).length > 0) {
                await saveHeroToFirestore(updates);
              }
            } else if (key !== null) {
              alert('Incorrect secret key.');
            }
          }
        });

        // Also attach the same editing prompt to the hero star icon.  When
        // the decorative star (‚ú®) is clicked, the user is prompted for the
        // secret key and can then modify the hero text and pixel animation.
        const starEl = document.getElementById('heroStar');
        if (starEl) {
          starEl.style.cursor = 'pointer';
          starEl.addEventListener('click', async () => {
            const key = prompt('Enter secret key to edit hero:');
            if (key === HERO_EDIT_KEY) {
              const titleEl = document.getElementById('heroTitle');
              const subtitleEl = document.getElementById('heroSubtitle');
              let updates = {};
              const newTitle = prompt('Enter new heading text:', titleEl ? titleEl.textContent : '');
              if (newTitle !== null && titleEl) {
                titleEl.textContent = newTitle;
                localStorage.setItem('pangeya_hero_title', newTitle);
                updates.title = newTitle;
              }
              const newSubtitle = prompt('Enter new subtitle:', subtitleEl ? subtitleEl.textContent : '');
              if (newSubtitle !== null && subtitleEl) {
                subtitleEl.textContent = newSubtitle;
                localStorage.setItem('pangeya_hero_subtitle', newSubtitle);
                updates.subtitle = newSubtitle;
              }
              const newParticle = prompt('Enter new pixel animation text:', particleText);
              if (newParticle !== null && newParticle.trim() !== '') {
                particleText = newParticle;
                localStorage.setItem('pangeya_particle_text', newParticle);
                updates.particleText = newParticle;
                // Update the display: regenerate particles or fallback via resizeCanvas
                resizeCanvas();
              }
              if (Object.keys(updates).length > 0) {
                await saveHeroToFirestore(updates);
              }
            } else if (key !== null) {
              alert('Incorrect secret key.');
            }
          });
        }
      });
    })();
  </script>
</body>
</html>